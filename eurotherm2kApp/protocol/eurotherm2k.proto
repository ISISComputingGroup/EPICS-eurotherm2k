## \file
## Stream Device Protocol for eurotherm 2000 series EI Bisynch
## will look for the records \$1SPLIT_ADD.A which contains GAD, \$1SPLIT_ADD.B which contains the LAD and \$1ERR which will process any errors
## GAD = First char of address, e.g. address = 1, GAD = 0, address = 12, GAD = 1
## LAD = Second char of address, e.g. address = 1, LAD = 1, address = 12, LAD = 2

locktimeout = 5000;

## Unfortunately, this is designed with a checksum terminator.
OutTerminator   = "";
replytimeout = 200;
## Setting a small readtimeout means that we can get data without needing a terminator
readtimeout  = 100;
extrainput   = Ignore;

#STX = "\x02"
#ETX = "\x03"
#EOT = "\x04"
#ENQ = "\x05"
#ACK = "\x06"

## Read value
## \code
## send: [EOT](GAD)(GAD)(LAD)(LAD)(CHAN)(C1)(C2)[ENQ]
## reply: [STX](CHAN)(C1)(C2)<DATA>[ETX](BCC)
## \endcode
## - $1 = PV PREFIX
## - $2 = command mnemonic
#############################################################################
read { InTerminator = "\x03"; out "\x04%(\$1SPLIT_ADD.A)1i%(\$1SPLIT_ADD.A)1i%(\$1SPLIT_ADD.B)1i%(\$1SPLIT_ADD.B)1i\$2\x05"; in "%*[\x18\x02]\$2%f"; }

## Read value, but in hex
readhex { InTerminator = "\x03"; out "\x04%(\$1SPLIT_ADD.A)1i%(\$1SPLIT_ADD.A)1i%(\$1SPLIT_ADD.B)1i%(\$1SPLIT_ADD.B)1i\$2\x05"; in "\x02\$2>%x"; }

## NOTE: we rely on readtimeout for the in commands. 
## Could use maxInput, but that screws up record initialisation (once inTerminator is set it can't be overwritten in the \@init handler)
##
## Write value
## \code
## send: [EOT](GAD)(GAD)(LAD)(LAD)[STX](CHAN)(C1)(C2)<DATA>[ETX](BCC)
## reply: [ACK] or [NAK], discarded as no terminator
## \endcode
## - $1 = device prefix, \$(P)
## - $2 = command mnemonic
#############################################################################
write {  InTerminator = ""; out "\x04%(\$1SPLIT_ADD.A)1i%(\$1SPLIT_ADD.A)1i%(\$1SPLIT_ADD.B)1i%(\$1SPLIT_ADD.B)1i\x02\$2%f\x03%6<xor>"; in "\x06"; @init{ read; }; @mismatch{ in "%(\$1ERR.PROC)r"; }; }

## Write a value in int rather than float
writeint {  InTerminator = ""; out "\x04%(\$1SPLIT_ADD.A)1i%(\$1SPLIT_ADD.A)1i%(\$1SPLIT_ADD.B)1i%(\$1SPLIT_ADD.B)1i\x02\$2%i\x03%6<xor>"; in "\x06"; @init{ read; }; @mismatch{ in "%(\$1ERR.PROC)r"; }; }
